/**
 * @file Game
 * @author Mike Joyce [hello@mikejoyce.io]
 */

/* TODO:
 * - Add leader board
 * - Add pause button
 * - Add bonus lives
 * - Make it tablet & mobile friendly
 */

import * as SFX from './sfx.js';
import * as Music from './music.js';
import { Engine } from './engine.js';
import { Resources } from './resources';

export const Game = (function() {

  /* Enemies Array.
   * All enemies generated by the Enemies.spawn() method are pushed
   * into this array.
   */
  const allEnemies = [];

  /* Gems Array.
   * All gems generated by the Gems.spawn() method are pushed
   * into this array.
   */
  const allGems = [];

  /* Pause the game by default to prevent the player moving around
   * when arrow keys are pressed. Set to false when the start or
   * game over screens are hidden from view.
   */
  let paused = true;

  /**
   * Constants
   * @type {Object}
   */
  const constants = {

  	// Default canvas text font family
  	FONT : '20pt ArcadeClassic',

  	// Default canvas text font color
  	FONT_COLOR: 'white',

  	// Game element height
  	ENTITY_HEIGHT : 50,

  	// Game element width
  	ENTITY_WIDTH : 50,

  	// Enemy minimum speed
  	MIN_SPEED : 50,

  	// Enemy max speed
  	MAX_SPEED : 400,

  	// Player's start x-position on the canvas
  	PLAYER_START_X : 300,

  	// Player's start y-position on the canvas
  	PLAYER_START_Y : 470,

  	// Player movement distance
  	PLAYER_MOVEMENT : 50,

  	// X position array for game elements
  	POSITION_X : [0, 100, 200, 300, 400, 500, 600],

  	// Y position array for game elements
  	POSITION_Y : [160, 230, 310, 390],

  	// Left canvas boundary
  	LEFT_BOUNDARY : 0,

  	// Top canvas boundary
  	TOP_BOUNDARY : 20,

  	// Right canvas boundary
  	RIGHT_BOUNDARY : 600,

  	// Bottom canvas boundary
  	BOTTOM_BOUNDARY : 470

  };


  $(document).ready(function() {

  	// Play background music
  	Music.track.play();

  	// Adjust background music volume
  	Music.track.volume(0.3);

  	// Hide the start screen on button click
  	$('#playGame').click(function() {

  		// Hide the start screen
  		$('#startScreen').fadeOut('fast');

  		// Play the select sound effect
  		SFX.gameSelect.play();

  		// Fade in the game music
  		Music.track.fade(0.3, 0.7, 2000);

  		/* Unpause the game to allow the player to move around
  		 * when arrow keys are pressed
  		 */
  		paused = false;

  	});

  	// Hide the game over screen on button click
  	$('#playAgain').click(function() {

  		// Hide the game over screen
  		$('#gameOver').hide()

  		// Play the select sound effet
  		SFX.gameSelect.play();

  		// Fade in the game music
  		Music.track.fade(0.3, 1.0, 1000);

  		/* Unpause the game to allow the player to move around
  		 * when arrow keys are pressed
  		 */
  		paused = false;

  	});

  	// Show the how to play screen on click
  	$('#howToOpen').click(function() {

  		// Play the select sound effect
  		SFX.gameSelect.play();

  		// Fade out the game music
  		Music.track.fade(0.7, 0.3, 2000);
  		$('#howTo').fadeIn('fast');

  	});

  	// Hide the how to play screen on click
  	$('#howToClose').click(function() {

  		// Play the select sound effect
  		SFX.gameSelect.play();

  		// Fade in the game music
  		Music.track.fade(0.3, 0.7, 2000);
  		$('#howTo').fadeOut('fast');

  	});

  	// Toggle game music
  	$('.toggle-music').click(function() {

  		if ($(this).hasClass('on')) {
  			Music.track.pause();
  			$(this).hide();
  			$('.toggle-music.off').show();
  		}

  		if ($(this).hasClass('off')) {
  			Music.track.play();
  			$(this).hide();
  			$('.toggle-music.on').show();
  		}

  	});

  });


  /**
   * @class Enemy
   * @constructor
   * @param {number} positionY
   * @param {number} speed
   */
  const Enemy = function(positionY, speed) {

  	// Set the enemy's image
    this.sprite = 'dist/images/enemy-bug.png';

    // Set a random x position on the canvas
    this.x = getRandomInt(-1000, -100);

    // Set the y position. Determined by the positionY argument
    this.y = positionY;

    // Set the enemy's height
  	this.height = constants.ENTITY_HEIGHT;

  	// Set the enemy's width
  	this.width = constants.ENTITY_WIDTH;

  	// Set the enemy's speed. Determined by the speed argument
    this.speed = speed;

  };

  /**
   * update - update the enemy's position on Engine.canvas
   * @memberOf Enemy
   * @param {string} deltaTime
   */
  Enemy.prototype.update = function(deltaTime) {

    /**
     * Multiply the position and speed the enemy object by delta time
     * to give the illusion of animation.
     */
    this.x = this.x + this.speed * deltaTime;

    /**
     * If the enemy goes off the right most side of the canvas,
     * reset it's position at a random negative position off
     * the left side of Engine.canvas.
    */
    if (this.x > Engine.canvas.width) {
      this.x = getRandomInt(-2000, -100);
    }

  };

  /**
   * render
   * @memberOf Enemy - Draw an enemy on Engine.canvas
   */
  Enemy.prototype.render = function() {
    Engine.ctx.drawImage(Resources.get(this.sprite), this.x, this.y);
  };


  /**
   * @class Enemies - spawns and removes enemies from Engine.canvas
   * @constructor
   */
  const Enemies = function() {

     /**
      * Enemies generated are pushed into this array
      * before being pushed into the global allEnemies array
      */
  	this.enemiesArray = [];

  };

  /**
   * spawn - spawn enemies on Engine.canvas
   * @memberOf Enemies
   * @param {number} total - total number of enemies to spawn
   */
  Enemies.prototype.spawn = function(total) {

  	for (let i = 0; i < total; i++) {

  		// Call the getRandomInt function and set the speed of the enemy.
  		const speed = getRandomInt(constants.MIN_SPEED, constants.MAX_SPEED);

  		// Call the getRandomInt function and set the players y position on the Engine.canvas.
  		const position = getRandomInt(0, 3);

  		// Instatiate a new enemy object.
  		this.enemiesArray[allEnemies.length] = new Enemy(constants.POSITION_Y[position], speed);

  		// Push the new enemy into the allEnemies array.
  		allEnemies.push(this.enemiesArray[allEnemies.length]);

  	}

  };

  /**
   * reset - clear all enemies from Engine.canvas
   * @memberOf Enemies
   */
  Enemies.prototype.reset = function() {
    const enemyCount = allEnemies.length;
    for (let i = 0; i < enemyCount; i++) {
      allEnemies.splice(i, allEnemies.length);
    }
  };

  // Instantiate a new Enemies object
  const enemies = new Enemies();

  /**
   * @class Gem - generates, clears and resets a collectable gem
   * @param {number} positionX - x position of the gem
   * @param {number} positionY - y position of the gem
   */
  const Gem = function(positionX, positionY) {

  	// Include the blue, green and orange gem images in an array
  	const gemArray = ['gem-blue.png', 'gem-green.png', 'gem-orange.png'];

  	// Set a random gem image from the gemArray
  	this.sprite = 'dist/images/' + gemArray[getRandomInt(0,2)];

  	// Set the gem's height
  	this.height = constants.ENTITY_HEIGHT;

  	// Set the gem's width
  	this.width = constants.ENTITY_WIDTH;

  	// Set a the x position of the gem
  	this.x = positionX;

  	// Set a the y position of the gem
  	this.y = positionY;

  };

  /**
   * render - draw a gem on Engine.canvas. Position is determined by random
   * positions generated from the POSITION_X and POSITION_y constant arrays.
   * @memberOf Gem
   */
  Gem.prototype.render = function() {
    Engine.ctx.drawImage(Resources.get(this.sprite), this.x, this.y);
  };

  /**
   * clear - hide the gem by setting it's x position to a negative value on Engine.canvas
   * @memberOf Gem
   */
  Gem.prototype.clear = function() {

  	this.x = -100;

  	// Play gem collect sound effect
  	SFX.gemCollect.play();

  };

  /**
   * reset - instantiates a new Gem, which in turn resets it's color and position on Engine.canvas
   * @memberOf Gem
   */
  Gem.prototype.reset = function() {
    gem = new Gem();
  };

  // Instantiate a new Gem object
  let gem = new Gem();

  /**
   * @class Gems - spawns and removes gems from Engine.canvas
   * @constructor
   */
  const Gems = function() {

  	/* Gems generated are pushed into this array
  	 * before being pushed into the global allGems array
  	 */
  	this.gemsArray = [];

  };

  /**
   * spawn
   * @memberOf Gems
   * @param {number} total - total number of gems to spawn
   */
  Gems.prototype.spawn = function(total) {

    for (let i = 0; i < total; i++) {

      // Call the getRandomInt function and set the gems x position on the Engine.canvas.
      const positionX = getRandomInt(0, 6);

      // Call the getRandomInt function and set the gems y position on the Engine.canvas.
      const positionY = getRandomInt(0, 3);

      // Instatiate a new gem object.
      this.gemsArray[allGems.length] = new Gem(constants.POSITION_X[positionX], constants.POSITION_Y[positionY]);

      // Push the new gem into the allGems array.
      allGems.push(this.gemsArray[allGems.length]);

    }

  };

  /**
   * reset - clear all gems from Engine.canvas
   * @memberOf Gems
   */
  Gems.prototype.reset = function() {
    const gemsCount = allGems.length;
    for (let i = 0; i < gemsCount; i++) {
      allGems.splice(i, allGems.length);
    }
  };

  // Instantiate a new Gems object
  const gems = new Gems();

  /**
   * @class Player - responsible for rendering the player, updating the
   * player's position on the canvas and updating the player's lives.
   * @constructor
   */
  const Player = function() {

  	// Set the player's image
  	this.sprite = 'dist/images/char-boy.png';

  	// Set the player's x position on the canvas
  	this.x = constants.PLAYER_START_X;

  	// Set the player's y position on the canvas
  	this.y = constants.PLAYER_START_Y;

  	// Set the player's height
  	this.height = constants.ENTITY_HEIGHT;

  	// Set the player's width
  	this.width = constants.ENTITY_WIDTH;

  	/* Set the player's default lives.
  	 * The player starts the game with 3.
  	 */
  	this.lives = 3;

  };

  /**
   * update - update the player's position on Engine.canvas
   * @memberOf Player
   */
  Player.prototype.update = function() {
    this.xNow = this.x;
    this.yNow = this.y;
  };

  /**
   * reset - resets the players position on Engine.canvas
   * @memberOf Player
   */
  Player.prototype.reset = function() {
  	this.x = constants.PLAYER_START_X;
  	this.y = constants.PLAYER_START_Y;
  };

  /**
   * hit - called when the player collides with an enemy
   * @memberOf Player
   */
  Player.prototype.hit = function() {
    this.x = constants.PLAYER_START_X;
    this.y = constants.PLAYER_START_Y;
    $("#collision").show().fadeOut();
    SFX.playerHit.play();
  };

  /**
   * updateLives - updates the player's lives
   * @memberOf Player
   * @param  {string} action - add/remove
   * @param  {number} value  - value to add/remove
   */
  Player.prototype.updateLives = function(action, value) {

  	// Add a life
  	if (action === 'add') {
      this.lives = this.lives + value;
  	}

  	// Remove a life
  	if (action === 'remove') {
  	  this.lives = this.lives - value;
  	}

  	// Update the lives stats
  	stats.updateLives(this.lives);

  };

  /**
   * render - draw the player on Engine.canvas
   * @memberOf Player
   */
  Player.prototype.render = function() {
    Engine.ctx.drawImage(Resources.get(this.sprite), this.x, this.y);
  };

  /**
   * handleInput - handle the left, up, right and down keyboard arrow keys input
   * @memberOf Player
   * @param  {number} key [description]
   */
  Player.prototype.handleInput = function(key) {

  	/* If the left arrow key is pressed and the
  	 * player is within the left boundary of the
  	 * canvas, allow the player to go move left.
  	 */
  	if (key === 'left' && this.x != constants.LEFT_BOUNDARY) {
  	 this.x = this.xNow + -constants.PLAYER_MOVEMENT;
  	}

  	/* If the up arrow key is pressed and the
  	 * player is within the top boundary of the
  	 * canvas, allow the player to move upwards.
  	 */
  	if (key === 'up' && this.y != constants.TOP_BOUNDARY) {
  	 this.y = this.yNow + -constants.PLAYER_MOVEMENT;
  	}

  	/* If the right arrow key is pressed and the
  	 * player is within the right boundary of the
  	 * canvas, allow the player to move right.
  	 */
  	if (key === 'right' && this.x != constants.RIGHT_BOUNDARY) {
  	 this.x = this.xNow + constants.PLAYER_MOVEMENT;
  	}

  	/* If the down arrow key is pressed and the
  	 * player is within the bottom boundary of the
  	 * canvas, allow the player to move down.
  	 */
  	if (key === 'down' && this.y != constants.BOTTOM_BOUNDARY) {
  	 this.y = this.yNow + constants.PLAYER_MOVEMENT;
  	}

  };

  // Instantiate new Player object
  const player = new Player();

  /**
   * @class Level - responsible for keeping track of and reseting the level
   * @constructor
   */
  const Level = function() {
  	this.level = 1;
  	enemies.spawn(2);
  	gems.spawn(2);
  };

  /**
   * update - updates the level
   * @memberOf Level
   */
  Level.prototype.update = function() {

    // Increase level
    this.level++;

    // Span enemies when the level is divisable by 2
    if (this.level % 2) {
      enemies.spawn(1);
    }

    // Reset gems
    gems.reset();

    // Spawn a random amount of collectable gems
    gems.spawn(getRandomInt(2,4));

    // Reset player's position
    player.reset();

    // Update level stat
    stats.updateLevel(this.level);

    // Update the score
    stats.updateScore();

    //  Play level up sound
    SFX.levelUp.play();

  };

  /**
   * reset
   * @memberOf Level
   */
  Level.prototype.reset = function() {

    // Reset to level 1
    this.level = 1;

    // Reset player's position
    player.reset();

    // Reset enemies
    enemies.reset();

    // Reset gem
    gem.reset();

    // Reset stats
    stats.reset();

    // Update player lives
    player.updateLives('add', 2);

    // Spawn enemies
    enemies.spawn(2);

    // Play game over sound
    SFX.gameOver.play();

    // Fade out the game music slightly
    Music.track.fade(1.0, 0.3, 1000);

    // Pause the game to prevent player movement
    paused = true;

    // Show game over screen
    $('#gameOver').show();

  };

  // Instantiate a new level object
  const level = new Level();

  /**
   * @class Stats - responsible for rendering, updating and reseting the game statisitcs,
   * namely the current level and score.
   * @constructor
   */
  const Stats = function() {
  	this.font = constants.FONT;
  	this.fontColor = constants.FONT_COLOR;
  	this.currentLevel = level.level;
  	this.currentLives = player.lives;
  	this.currentScore = 0;
  	this.currentGems = 0;
  };

  /**
   * render
   * @memberOf Stats - renders stat bar, level text, score text, lives count and gems count.
   */
  Stats.prototype.render = function() {
  	Engine.ctx.fillStyle = 'rgba(0,0,0,0.5)';
  	Engine.ctx.fillRect(0,50, 707, 45);
  	this.level();
  	this.score();
  	this.lives();
  	this.gems();
  };

  /**
   * level - draws level text
   * @memberOf Stats
   */
  Stats.prototype.level = function() {
  	Engine.ctx.font = this.font;
  	Engine.ctx.fillStyle = this.fontColor;
  	Engine.ctx.textAlign = 'start';
  	Engine.ctx.fillText('Level '+ this.currentLevel, 10, 82);
  };

  /**
   * updateLevel - update current level stat
   * @memberOf Stats
   * @param {number} level - current level
   */
  Stats.prototype.updateLevel = function(level) {
    this.currentLevel = level;
  };

  /**
   * score - set current score text
   * @memberOf Stats
   */
  Stats.prototype.score = function() {
  	Engine.ctx.font = this.font;
  	Engine.ctx.fillStyle = this.fontColor;
  	Engine.ctx.textAlign = 'end';
  	Engine.ctx.fillText(this.currentScore, 700, 82);
  };

  /**
   * updateScore - update current score stat
   * @memberOf Stats
   */
  Stats.prototype.updateScore = function() {
    this.currentScore = this.currentScore + 600;
  };

  /**
   * lives - draws lives icon & text
   * @memberOf Stats
   */
  Stats.prototype.lives = function() {
    Engine.ctx.drawImage(Resources.get('dist/images/stat-heart.png'), 430, 62);
    Engine.ctx.font = this.font;
    Engine.ctx.fontStyle = this.fontColor;
    Engine.ctx.textAlign = 'start';
    Engine.ctx.fillText('x '+ this.currentLives, 465, 82);
  };

  /**
   * updateLives - update current lives stat
   * @memberOf Stats
   * @param {number} lives - current number of lives
   */
  Stats.prototype.updateLives = function(lives) {
    this.currentLives = lives;
  };

  /**
   * gems - draws gems icon & text
   * @memberOf Stats
   */
  Stats.prototype.gems = function() {
    Engine.ctx.drawImage(Resources.get('dist/images/stat-gem.png'), 340, 62);
    Engine.ctx.font = this.font;
    Engine.ctx.fontStyle = this.fontColor;
    Engine.ctx.textAlign = 'start';
    Engine.ctx.fillText('x '+ this.currentGems, 370, 82);
  };

  /**
   * updateGems - update current gem stat
   * @memberOf Stats
   */
  Stats.prototype.updateGems = function() {
    this.currentGems++;
    this.currentScore = this.currentScore + 300;
  };

  /**
   * reset - reset stats
   * @memberOf Stats
   * @return {[type]} [description]
   */
  Stats.prototype.reset = function() {
    $('#gameOver #score').html(this.currentScore);
    this.currentScore = 0;
    this.currentGems = 0;
    this.currentLevel = level.level;
  };

  // Instatiate a new Stats object
  const stats = new Stats();

  /**
   * Listen for key presses and call the player.handleInput function if the game isn't paused.
   * @param {Object} event
   */
  document.addEventListener('keydown', function(event) {

    const allowedKeys = {
      37: 'left',
      38: 'up',
      39: 'right',
      40: 'down'
    };

    if (!paused) {
    	player.handleInput(allowedKeys[event.keyCode]);
  	}

  });

  /**
   * getRandomInt
   * @param  {number} min - minium number to generate
   * @param  {number} max - maximum number to generate
   * @return {number} random integer
   */
  function getRandomInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1) + min);
  }

  /**
   * Return public variables/objects
   */
  return {
    allEnemies,
    allGems,
    player,
    stats,
    enemies,
    level
  }

})();
